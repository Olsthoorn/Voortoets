
# %% [markdown]
# # Get regional models and their add_flowing_data
#
# Functions are given to scan projects carried out with the Flamish
# "Grondwatersimulator" and # find out which regional models it contains.
# For this it use Modflows binary .grb files of the regional models
# that first were generated by Modflow6 after removing the NOGRB
# option from the no_permits.disv file in the regional directory of each project.
#
# The regional model data are put in a seaparate data/regional_models folder
# for easy later use.
#
# These .grb files are used to get the cell vertices and around
# each model a convex hull is generated and their centroid is computed.
#
# The subsurface info of ech regional model (k, k33, ss and sy) is also
# extracted from the specific projects folder, added to a GeoDataFrame
# and written to diskin the data/regional_models folder as a geopackage.
#
# The grondwatersimulator contains for Flanders three regional models.
# The k, k33, ss and sy data of each of them is layered, i.e. has
# a constant value for each layer througout the entire regional model.
#
# TO 2025-10-24

# %%
# %% 
import os
import numpy as np
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import MultiPoint, Polygon
from shapely.ops import unary_union, polygonize
from scipy.spatial import Delaunay
from flopy.mf6.utils import MfGrdFile
from glob import glob
from pathlib import Path
import etc

# %% [markdown]
# # Get GeoDataFrame with their regional model info
# 
# 1. Read the .grb file of the regional model of each project.
# 2. Compute its convec hull and centroid.
# 3. Put this in a GeoDataFrame.
# 3. Add which regional model the project has based on its centroid.
#

# %%
def load_model_grids_from_zipfolder(projects_folder):
    """Read all userinput.json files from ZIPs in folder into one GeoDataFrame."""
    
    pr_names = glob(projects_folder + '/*.zip')
    pr_names = [p.replace('.zip', '') for p in pr_names]
    
    grds = []

    for pr_name in pr_names:
        grb_file = os.path.join(pr_name, 'regional', 'no_permits.disv.grb')
        assert os.path.isfile(grb_file), f"No file <{grb_file}>"
            
        print(f"Processing <{os.path.basename(os.path.basename(pr_name))}>")
    
        grd = MfGrdFile(grb_file)
        points = MultiPoint(grd.verts)
        
        # Compute convex hull
        hull = MultiPoint(points).convex_hull
        
        reg_grd = gpd.GeoDataFrame(geometry = [hull])
        reg_grd['project'] = os.path.basename(pr_name)
        reg_grd['model_type'] = 'regional'        
        reg_grd.crs="EPSG:31370"
        
        grds.append(reg_grd)

    if not grds:
        print("No valid projects found.")
        return None

    grd_gpd = gpd.pd.concat(grds, ignore_index=True)
    # --- reorder columns
    
    grd_gpd['xC'] = np.round(grd_gpd.geometry.centroid.x)
    grd_gpd['yC'] = np.round(grd_gpd.geometry.centroid.y)

    # Centroids models W, N and E approximately
    mdl_centroids = {
         'W': {'x':  91500., 'y': 183800.},
         'N': {'x': 181200., 'y': 206100.},
         'E': {'x': 193300., 'y': 168800.}
        }

    mask_W = np.isclose(grd_gpd['xC'], mdl_centroids['W']['x'], atol=300.)
    mask_N = np.isclose(grd_gpd['yC'], mdl_centroids['N']['y'], atol=300.)
    mask_E = np.isclose(grd_gpd['xC'], mdl_centroids['E']['x'], atol=300.)
    
    # --- which regional model (W, E or N) we have
    grd_gpd['model'] = 'any'
    grd_gpd.loc[mask_N, 'model'] = 'N'
    grd_gpd.loc[mask_E, 'model'] = 'E'
    grd_gpd.loc[mask_W, 'model'] = 'W'

    grd_gpd.loc[mask_N, 'model_type'] = 'regional_N'
    grd_gpd.loc[mask_E, 'model_type'] = 'regional_E'
    grd_gpd.loc[mask_W, 'model_type'] = 'regional_W'
    
    cols = [c for c in grd_gpd.columns if c != 'geometry'] + ['geometry']
    
    return grd_gpd[cols] 

# %% [markdown]
# # Get regional model grid
#
# Given the path to the binary Modflow6 .grb file, the grid is read,
# it's convec hull and centroid are computed and added to the
# created 1-layer GeoDataFrame.
#
# %%
def get_grid(gr_file, crs="EPSG:31370", ax=None):
    """Return geodataframe of gr_file (.grb file).
    
    Parameters
    ----------
    gr_file: Path of str pointing at mf6 .grb file.
        binadary Modflow grid
    crs: crs code
        crs
    ax: Axes object | None
        if not None, plot convex hull and centroid
    """
    gr = MfGrdFile(gr_file)    
    hull = MultiPoint(gr.verts).convex_hull
    xC, yC = hull.centroid.xy
    reg_grd = gpd.GeoDataFrame(geometry = [hull], crs=crs)
    reg_grd['model'] = os.path.basename(gr_file)
    reg_grd['xC'] = np.round(xC)
    reg_grd['yC'] = np.round(yC)
    
    if ax:
        reg_grd.plot(ax=ax, linewidth=1, ec='b', fc='none')
        ctr = gpd.GeoDataFrame(geometry=[hull.centroid], crs=crs)
        ctr.plot(ax=ax, color='r')
    
    cols = [c for c in reg_grd.columns if not c=='geometry'] + ['geometry']
    
    return reg_grd[cols]

# %% [markdown]
# # Read aquifer data from npf and sto files of regional models
#
# The aquifer data of all three models is layered. I.e. it's constant
# throughout the aquifer/aquitard/model layer.
# The name of the models '.npf' or '.sto' file given, the data
# is read from these files and returned to be included
# in a dictionary or GeoDataFrame for further direct use.
#

# %% --- read LAYERED mf6 datafiles (npf and sto)

def read_layered_modflow_file(filename, blocks):
    """
    Read a MODFLOW-style file with 'LAYERED' blocks and 'CONSTANT' values.

    Parameters
    ----------
    filename : str
        Path to the file (e.g. .sto, .npf, etc.)
    blocks : list of str
        Names of the data blocks to extract, e.g. ["ss", "sy"] or ["k", "k33"]

    Returns
    -------
    dict
        Dictionary with block names as keys and NumPy arrays of floats as values.
    """
    
    # --- dictionary with results having block names as keys
    results = {b: [] for b in blocks}
    
    # --- key (name of active block)
    active_block = None

    with open(filename, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            # --- detect start of a new block
            for b in blocks:
                if f"{b}  LAYERED" in line:
                    active_block = b
                    break
            else:
                # --- detect end of blocks
                if "END griddata" in line or "END" in line:
                    active_block = None
                    
                # --- active block line
                elif active_block and "CONSTANT" in line:
                    try:
                        val = float(line.replace("CONSTANT", "").strip())
                        results[active_block].append(val)
                    except ValueError:
                        pass  # --- skip malformed lines

    # --- convert to numpy arrays
    for b in results:
        results[b] = np.array(results[b])

    return results # --- dictionary with blocks as keys and np.arrays as values

# %% [markdown]
# # Regional grid data
#
# There are three different regional grid which will be called 'W', 'E' and 'N'.
# These each grid are selected from a project that contains it.
# A dict is created that contains the x and y of the grid's centroid,
# it's convec hull, while the k, k33, ss and sy data are obtained
# from the specific projects and added.
# Then the dict is converted to a GeoDataFrame and saved to disk
# as a geopackage for later retrieval.
#
# Note that the k, k33, ss and sy data for the regional models is all
# layers, i.e. the values are constant per layer. Which makes things
# a little easier to handld.
#
# The .grb file and the geopackage constains all grid, layer elevation and
# subsurface propertie values required for local analysis.

# %% -- Regional grid data
def get_regional_model_data(projects_folder, gdf_reg_mdl):
    """Generate geopackage with essential regional model data.
    
    There are three regional models 'W', 'E' and 'N'
    Get them from the projects that contain them.
    Extract their convex_hull, centroid, k, k33, ss and sy values.
    Put all in a dict.
    Convert the dict to a GeoDataFrame.
    Save this GeoDataFrame to disk as a geopackage for later retrieval
    
    Parameters
    ----------
    project_folder: path
        folder holding the projects with all their modelling info.
    gdf_reg_mdl: GeoDataFrame   
        GeoDataFrame with for all projects the convex hull geometry
        centroid coordinates, project name and model key ('W', 'E', 'N')
    """
    # --- folder where the data of the three regional grids will be stored
    reg_mdl_folder = Path(os.path.join(
                    projects_folder, '../regional_grids')).resolve()
    assert os.path.isdir(reg_mdl_folder), (
                                f"No folder <{str(reg_mdl_folder)}>")

    # --- dict with regional grid data
    reg_data = {}

    for mdl in 'W', 'N', 'E':
        
        # --- Get the first project with on of the regional grids
        mask  = gdf_reg_mdl['model'] == mdl
        index = gdf_reg_mdl.index[mask][0]
        
        #  --- Add to dict
        reg_data[mdl] = dict(gdf_reg_mdl.loc[index])
        
        # --- Model type
        reg_data[mdl]['model_type'] = 'regional_' + mdl
        
        # --- Get project name holding this reg. model
        project = reg_data[mdl]['project']
        
        # --- Get conductivity and storage data for this reg model
        npf_file = os.path.join(projects_folder, project, 'regional', 'no_permits.npf')
        sto_file = os.path.join(projects_folder, project, 'regional', 'no_permits.sto')
        assert os.path.isfile(npf_file), "No file <{npf}>"
        assert os.path.isfile(sto_file), "No file <{sto}>"
        
        npf = read_layered_modflow_file(npf_file, ("k", "k33"))
        sto = read_layered_modflow_file(sto_file, ("ss", "sy"))
        
        # --- Add conductivity data to dict
        reg_data[mdl]['k'] = npf['k']
        reg_data[mdl]['k33'] = npf['k33']
        
        # --- Add storage data to dict
        reg_data[mdl]['ss']  = sto['ss']
        reg_data[mdl]['sy']  = sto['sy'] 

    # --- Convert dict to GeoDataFrame
    gdf = gpd.GeoDataFrame.from_dict(reg_data, orient='index', crs="EPSG:31370")

    # --- Save GeoDataFrame to disk as a geopackage
    gdf.to_file(os.path.join(reg_mdl_folder, "regional_models.gpkg"), driver="GPKG")
    
    return gdf
   
# %% [markdown]
# # Get regional grid data
#
# 1. Scan all projects and set which regional model each uses.
# 2. For each regional model select the first project using it.
# 3. Get the .grb file and compute centroid and convec hull.
# 4. Get npf and sto file and get k, k33, ss and sy
# 5. All these data is put in a dictionary
# 6. This dict is converted to GeoDataFrame
# 7. The convex hull of each of the three regional models is plotted
# 8. A label and centroid are added to the plot
# 7. This GeoDataFrame is saved to disk as geopckage
#

# %% --- Get regional model data (k, k33, ss, sy) and plot their convec hull
try:
    projects_folder = os.path.join(os.getcwd(), '../data', '6194_GWS_testen')
    assert os.path.isdir(projects_folder), f"Path not found <{projects_folder}>"
except Exception as e:
    projects_folder = os.path.join(os.getcwd(), 'data', '6194_GWS_testen')
    assert os.path.isdir(projects_folder), f"Path not found <{projects_folder}>"

# --- get gdf with regional model data for all projects (convex_hull geometry)
gdf_reg_mdl = load_model_grids_from_zipfolder(projects_folder)

gdf_reg_data = get_regional_model_data(projects_folder, gdf_reg_mdl)

ax = etc.newfig("Convec hull of all regional models", "xB", "yB")

gdf_reg_data.plot(ax=ax, fc='none', ec='b', linewidth=0.25)

# --- plot centroid and label with model name
shift_y = 1000. # m shift label up

for id in gdf_reg_data.index:
    rec = gdf_reg_data.loc[id]
    xC, yC = rec['xC'], rec['yC']
    ax.text(xC, yC + shift_y, rec['model_type'], ha='center', va='bottom')
    
    ax.plot(xC, yC, 'ro', label='Centroid of regional model')


# %% [markdown]
# # Show the grid of each of the 3 regional models
#
# 1. Get the three regional model grid files (.grb) in the regional_models directory
# Plot their convec hull.
# Plot a label
# Plot the vertices of each model in a different colot.
#

# %% --- plot the grid of the three regional models
clrs = etc.color_cycler()

grds = []

ax = etc.newfig("Regional grids", "xB", "yB")

# --- use the grid (.grb) files of the regional models
for gr_file in glob(os.path.join(projects_folder, '../regional_grids') + '/*.grb'):
    clr = next(clrs)
    
    # --- Get regional grid's convec hull and centroid
    reg_grd = get_grid(gr_file, crs="EPSG:31370", ax=ax)
    
    # --- Get full grid to allow plotting the grid vertices
    gr = MfGrdFile(gr_file)
    ax.plot(*gr.verts.T, '.', color=clr, lw=0.1, alpha=0.05,
            label=os.path.basename(gr_file))
    
    # --- Get the centroid's coordinates
    xC, yC = float(reg_grd.centroid.x[0]), float(reg_grd.centroid.y[0])
    
    # --- Plot label
    ax.text(xC, yC,
            reg_grd['model'][0].replace('.disv.grb', '').replace('region', 'grid'),
            ha='center', va='bottom')
    
    grds.append(reg_grd)

ax.legend()
    
# --- All grds in a GeoDataFrame
grds = gpd.pd.concat(grds, ignore_index=True)

    
# %% [markdown]
# # Conclusion
#
# There are three regional models as proven by the convec hulls.
# They are called here 'W', 'E' and 'N'
